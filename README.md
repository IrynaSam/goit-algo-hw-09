# Видача решти: порівняння алгоритмів

## Вступ

У цьому проєкті реалізовано дві функції для видачі решти покупцеві з використанням набору монет `[50, 25, 10, 5, 2, 1]`:

1. `find_coins_greedy` — реалізація жадібного алгоритму.
2. `find_min_coins` — реалізація алгоритму динамічного програмування для мінімізації кількості монет.

---

## Жадібний алгоритм (`find_coins_greedy`)

Алгоритм завжди обирає найбільшу монету, яка не перевищує залишок суми.

### Плюси:

- Швидке виконання.
- Мінімальне використання ресурсів.
- Простота реалізації.

### Мінуси:

- Не гарантує мінімальну кількість монет (у випадку нестандартних наборів).

---

## Динамічне програмування (`find_min_coins`)

Алгоритм шукає оптимальну (мінімальну) кількість монет для кожної можливої проміжної суми до заданої.

### Плюси:

- Завжди знаходить оптимальне рішення.
- Працює з будь-яким набором монет.

### Мінуси:

- Більше використання пам’яті.
- Може бути повільнішим на великих сумах.

---

## Результати тестування

```text
Сума: 54
Жадібний:              {50: 1, 2: 2}       | Час: 0.000000 сек
Динамічне програмування: {2: 2, 50: 1}     | Час: 0.000998 сек

Сума: 113
Жадібний:              {50: 2, 10: 1, 2: 1, 1: 1}
Динамічне програмування: {1: 1, 2: 1, 10: 1, 50: 2}

Сума: 198
Жадібний:              {50: 3, 25: 1, 10: 2, 2: 1, 1: 1}
Динамічне програмування: {1: 1, 2: 1, 10: 2, 25: 1, 50: 3}

```

| Сума | Жадібний (час, сек) | Динамічне (час, сек) | Різниця у рішенні |
| ---- | ------------------- | -------------------- | ----------------- |
| 54   | 0.000000            | 0.000998             | Немає             |
| 113  | 0.000000            | 0.000000             | Немає             |
| 198  | 0.000000            | 0.000000             | Немає             |

## Висновки

Жадібний алгоритм показує високу швидкість, простий у реалізації, але не завжди гарантує мінімальну кількість монет.

Динамічне програмування трохи повільніше, але завжди знаходить оптимальне рішення.

Якщо набір монет стандартний (наприклад, як у валюті), обидва підходи працюють однаково.

Для нестандартних наборів або ситуацій, де важливо мінімізувати кількість монет, рекомендовано використовувати алгоритм динамічного програмування.
